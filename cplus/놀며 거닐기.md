nolme의 철학. modern c++도 그렇게 돌아다녀 보자. 

# cpp best practices 

## style 

consistency. 일관성이 가장 중요하다. 

https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.ClangFormat#review-details
.clang_format 파일

## 유지보수 

### Consider Avoiding Boolean Parameters

뜻을 알면 다른 것도 보인다. 

f(false, 1, 3)에서 false는 어떤 의미일까? 결과 값도 bool이면 알기 어려운 경우가 있다. 

### Avoid Raw Loops

알고리즘을 사용한다. LINQ 정도는 아니더라도 c++도 필요한 대부분이 제공된다. 


## strong type interface

Bad Idea:
```c++
std::string find_file(const std::string &base, const std::string &pattern);
```

Better Idea:
```c++
std::filesystem::path find_file(const std::filesystem::path &base, const std::regex &pattern);
```

그렇다. 타잎, 타잎!


# c++ core guidelines 

R.22: Use make_shared() to make shared_ptrs

Reason
If you first make an object and then give it to a shared_ptr constructor, you (most likely) do one more allocation (and later deallocation) than if you use make_shared() because the reference counts must be allocated separately from the object.

Example
Consider:
```c++
shared_ptr<X> p1 { new X{2} }; // bad
auto p = make_shared<X>(2);    // good
```
The make_shared() version mentions X only once, so it is usually shorter (as well as faster) than the version with the explicit new.

Enforcement
(Simple) Warn if a shared_ptr is constructed from the result of new rather than make_shared.

shared_ptr<X> p1{new X{2}} 에서 X가 두 번 할당된다고 한다. 진짜로 그런가? 왜 그런가?

X가 두 번 할당되지는 않고, 임시로 참조를 하는 오브젝트를 갖고 shared_ptr로 만든다. 
다른 구현은 조금 다를 수 있지만 포인터에 대한 레퍼런스를 만드는 동안에 필요할 수 있다. 

## 철학

P.1: Express ideas directly in code
P.2: Write in ISO Standard C++
P.3: Express intent
P.4: Ideally, a program should be statically type safe
P.5: Prefer compile-time checking to run-time checking
P.6: What cannot be checked at compile time should be checkable at run time
P.7: Catch run-time errors early
P.8: Don’t leak any resources
P.9: Don’t waste time or space
P.10: Prefer immutable data to mutable data
P.11: Encapsulate messy constructs, rather than spreading through the code
P.12: Use supporting tools as appropriate
P.13: Use support libraries as appropriate

정확하고, 간결하고, 읽기 쉽고, 쓰기 쉬운 코드를 작성한다. 정확한 코드가 가장 중요하다. 
게임 서버는 성능도 중요하지만 위를 만족하면 최적화도 쉽다. 


## User-Defined Literals 

63_s, 123.45_km, 100_m 

```c++

namespace Distance{

  namespace Unit{
    MyDistance operator "" _km(long double d){
      return MyDistance(1000*d);
    }
    MyDistance operator "" _m(long double m){
      return MyDistance(m);
    }
    MyDistance operator "" _dm(long double d){
      return MyDistance(d/10);
    }
    MyDistance operator "" _cm(long double c){
      return MyDistance(c/100);
    }
  }
}
```

c++17에서는 "" 와 _km 사이에 공백이 없어도 된다. 


